---
title: "Comparison of inference under the host repertoire model in TreePPL vs RevBayes"
author: "Mariana Braga"
date: last-modified
date-format: long
format: 
  html:
    code-fold: true
    code-summary: "Show the code"
editor: source
editor_options: 
  chunk_output_type: console
execute:
  warning: false
---

Packages

```{r}
#| label: "packages"
#| message: FALSE

#install_github("treeppl/treepplr")
library(treepplr)
library(tidyverse)
library(ape)
library(ggtree)
library(evolnets)
library(coda)
library(RevGadgets)
library(patchwork)
library(kdensity)
```

## 1. Prepare data for analyses

Create symbiont tree, host tree, and interaction matrix.

```{r}
#| eval: false
#| label: simulate_data

tree <- rcoal(4, rooted = TRUE)
tree$tip.label <- paste0("S", 1:4)
height <- node.depth.edgelength(tree)[1]
tree$edge.length <- tree$edge.length * (2.0/height)

is.binary(tree)
is.ultrametric(tree)
is.rooted(tree)

host_tree <- rcoal(3, rooted = TRUE)
host_tree$tip.label <- paste0("H", 1:3)
plot(host_tree)
axisPhylo()

matrix <- matrix(data = c(2,0,2, 2,0,0, 2,2,0, 0,2,0), nrow = 4, ncol = 3, byrow = TRUE)
rownames(matrix) <- tree$tip.label
colnames(matrix) <- host_tree$tip.label

# write files
write.csv(matrix, "data/matrix.csv", row.names = TRUE)
write.nexus.data(matrix, "data/matrix.nex", format = "standard")
write.tree(host_tree, "data/host_tree.tre")
write.tree(tree, "data/tree.tre")

# add stem branch to symbiont tree
tree_string <- readLines("data/tree.tre")
tree_tiny_stem_string <- sub(");$", "):0.01;", tree_string)
tree_long_stem_string <- sub(");$", "):2.0;", tree_string)

writeLines(tree_tiny_stem_string, "data/tree_tiny_stem.tre")
writeLines(tree_long_stem_string, "data/tree_long_stem.tre")
```

```{r}
#| echo: false
#| label: read_data

tree <- read.tree("data/tree.tre")
host_tree <- read.tree("data/host_tree.tre")
matrix <- read.csv("data/matrix.csv", row.names = 1) %>% as.matrix()
```

Because RevBayes has it's own way to label tree nodes, we'll use the symbiont tree processed by RevBayes to keep track of node labels and be able to match them later. Then we can plot all data together.

```{r}
#| label: plot_data
#| fig-width: 7
#| fig-height: 6

symbiont_tree <- read_tree_from_revbayes("data/tree_tiny_stem_Rev.tre")

plot_data <- plot_matrix_phylo(matrix, at_nodes = NULL, symbiont_tree, host_tree, find_modules = FALSE)
plot_data[[1]] <- plot_data[[1]] + geom_nodelab(size = 3, hjust = -0.1)
plot_data

```


## 2. Run treeppl

```{r}
#| label: run_treeppl

# symbiont_tree: TreeLabeled, ntips: Int, nhosts: Int,
# interactions: Int[], host_distances: Real[],
# dMean: Real, tune: Real

ntips <- Ntip(symbiont_tree)
nhosts <- Ntip(host_tree)
interactions <- matrix
host_distances <- cophenetic.phylo(host_tree)
dMean <- sum(host_distances) / factorial(nhosts)
tune <- 0.9

# I can't write a tree object to the json format that treeppl understands yet
```


## 3. Output analysis

### 3.1 RevBayes

```{r}
#| label: convergence_rb

long_rb_log1 <- read.table("output/long_stem/revbayes/long.1.test4x3.log", header = TRUE)
long_rb_log2 <- read.table("output/long_stem/revbayes/long.2.test4x3.log", header = TRUE)

# take only columns of interest
long_rb_log1 <- long_rb_log1[,c(1,5:6,8:11)] %>% filter(Iteration > 100000)
long_rb_log2 <- long_rb_log2[,c(1,5:6,8:11)] %>% filter(Iteration > 100000)

# give them better column names
colnames(long_rb_log1) <- colnames(long_rb_log2) <- c("iteration","clock","beta", "gain01", "loss10", "gain12", "loss21")

# convergence test
gelman.diag(mcmc.list(as.mcmc(long_rb_log1), as.mcmc(long_rb_log2)))

effectiveSize(long_rb_log1)
effectiveSize(long_rb_log2)
```

Plot posterior distribution for each parameter

```{r}
#| label: param_dens_rb
#| fig-width: 5
#| fig-height: 7

trace_long_rb <- list(long_rb_log2)

params <- colnames(long_rb_log1)[-1]

dens_long_rb_list <- list()
for(i in seq_along(params)){
  dens_long_rb_list[i] <- plotTrace(trace_long_rb, vars = params[i])  
}
wrap_plots(dens_long_rb_list, ncol = 2)

```

Test if beta > 0

```{r}
#| label: bayes_factor

# Bayes factor

d_prior <- dexp(x=0, rate=1)

kd_beta <- kdensity(x = long_rev_log2$beta,
                    kernel='gamma',
                    support=c(0,Inf),
                    bw = 0.02)
max = kd_beta(0)

(BF <- d_prior/max)  # beta not different from zero
```




